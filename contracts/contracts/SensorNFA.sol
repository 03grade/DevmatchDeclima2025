// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol";

/**
 * @title SensorNFA
 * @dev Non-Fungible Agent contract for D-Climate sensors using Oasis Sapphire
 * Each sensor is represented as an NFT with confidential metadata and reputation scoring
 */
contract SensorNFA is ERC721, Ownable, ReentrancyGuard {
    using Sapphire for bytes;
    
    // Sensor metadata structure
    struct SensorMetadata {
        string sensorId;           // UUID generated by ROFL
        uint256 reputationScore;   // Starting at 100, can go 0-200
        uint256 mintTimestamp;     // When sensor was minted
        string ipfsMetadata;       // IPFS hash for additional metadata
        bool isActive;             // Sensor operational status
        uint256 totalSubmissions;  // Total data submissions count
        uint256 lastSubmission;    // Timestamp of last data submission
    }
    
    // Events
    event SensorMinted(
        address indexed owner,
        uint256 indexed tokenId,
        string indexed sensorId,
        uint256 timestamp
    );
    
    event ReputationUpdated(
        string indexed sensorId,
        uint256 oldScore,
        uint256 newScore,
        string reason
    );
    
    event SensorStatusChanged(
        string indexed sensorId,
        bool isActive,
        uint256 timestamp
    );
    
    // State variables
    mapping(string => uint256) public sensorIdToTokenId;  // sensorId => tokenId
    mapping(uint256 => SensorMetadata) public sensorMetadata;  // tokenId => metadata
    mapping(address => string[]) public ownerToSensorIds;  // owner => sensorId array
    mapping(string => bool) public sensorExists;  // sensorId => exists
    
    uint256 private _nextTokenId = 1;
    uint256 public constant INITIAL_REPUTATION = 100;
    uint256 public constant MAX_REPUTATION = 200;
    uint256 public constant MIN_REPUTATION = 0;
    
    // ROFL authorized addresses
    mapping(address => bool) public authorizedROFL;
    
    constructor(address initialOwner) ERC721("D-Climate Sensor", "DCSENSOR") Ownable(initialOwner) {}
    
    /**
     * @dev Add authorized ROFL address (only owner)
     */
    function addAuthorizedROFL(address roflAddress) external onlyOwner {
        authorizedROFL[roflAddress] = true;
    }
    
    /**
     * @dev Remove authorized ROFL address (only owner)
     */
    function removeAuthorizedROFL(address roflAddress) external onlyOwner {
        authorizedROFL[roflAddress] = false;
    }
    
    /**
     * @dev Modifier to check if caller is authorized ROFL
     */
    modifier onlyAuthorizedROFL() {
        require(authorizedROFL[msg.sender], "Not authorized ROFL");
        _;
    }
    
    /**
     * @dev Mint a new sensor NFA with confidential sensorId generation
     * @param sensorId Unique sensor identifier generated by ROFL
     * @param ipfsMetadata IPFS hash containing sensor specifications
     */
    function mintSensor(
        string calldata sensorId,
        string calldata ipfsMetadata
    ) external nonReentrant returns (uint256) {
        require(bytes(sensorId).length > 0, "Invalid sensor ID");
        require(!sensorExists[sensorId], "Sensor ID already exists");
        
        uint256 tokenId = _nextTokenId++;
        
        // Store sensor metadata with confidential access
        sensorMetadata[tokenId] = SensorMetadata({
            sensorId: sensorId,
            reputationScore: INITIAL_REPUTATION,
            mintTimestamp: block.timestamp,
            ipfsMetadata: ipfsMetadata,
            isActive: true,
            totalSubmissions: 0,
            lastSubmission: 0
        });
        
        // Update mappings
        sensorIdToTokenId[sensorId] = tokenId;
        ownerToSensorIds[msg.sender].push(sensorId);
        sensorExists[sensorId] = true;
        
        // Mint the NFT
        _safeMint(msg.sender, tokenId);
        
        emit SensorMinted(msg.sender, tokenId, sensorId, block.timestamp);
        
        return tokenId;
    }
    
    /**
     * @dev Update sensor reputation (only authorized ROFL)
     * @param sensorId The sensor identifier
     * @param newScore New reputation score (0-200)
     * @param reason Reason for reputation change
     */
    function updateReputation(
        string calldata sensorId,
        uint256 newScore,
        string calldata reason
    ) external onlyAuthorizedROFL {
        require(sensorExists[sensorId], "Sensor does not exist");
        require(newScore <= MAX_REPUTATION, "Score exceeds maximum");
        
        uint256 tokenId = sensorIdToTokenId[sensorId];
        uint256 oldScore = sensorMetadata[tokenId].reputationScore;
        
        sensorMetadata[tokenId].reputationScore = newScore;
        
        emit ReputationUpdated(sensorId, oldScore, newScore, reason);
    }
    
    /**
     * @dev Update sensor activity status (owner or authorized ROFL)
     * @param sensorId The sensor identifier
     * @param isActive New activity status
     */
    function setSensorStatus(string calldata sensorId, bool isActive) external {
        require(sensorExists[sensorId], "Sensor does not exist");
        
        uint256 tokenId = sensorIdToTokenId[sensorId];
        
        // Check if caller is owner or authorized ROFL
        require(
            ownerOf(tokenId) == msg.sender || authorizedROFL[msg.sender],
            "Not authorized to change status"
        );
        
        sensorMetadata[tokenId].isActive = isActive;
        
        emit SensorStatusChanged(sensorId, isActive, block.timestamp);
    }
    
    /**
     * @dev Update sensor submission count (only authorized ROFL)
     * @param sensorId The sensor identifier
     */
    function recordSubmission(string calldata sensorId) external onlyAuthorizedROFL {
        require(sensorExists[sensorId], "Sensor does not exist");
        
        uint256 tokenId = sensorIdToTokenId[sensorId];
        sensorMetadata[tokenId].totalSubmissions++;
        sensorMetadata[tokenId].lastSubmission = block.timestamp;
    }
    
    /**
     * @dev Get sensor metadata (public view with reputation-based access)
     * @param sensorId The sensor identifier
     */
    function getSensorMetadata(string calldata sensorId) 
        external 
        view 
        returns (SensorMetadata memory) 
    {
        require(sensorExists[sensorId], "Sensor does not exist");
        uint256 tokenId = sensorIdToTokenId[sensorId];
        return sensorMetadata[tokenId];
    }
    
    /**
     * @dev Get all sensor IDs owned by an address
     * @param owner The owner address
     */
    function getSensorsByOwner(address owner) external view returns (string[] memory) {
        return ownerToSensorIds[owner];
    }
    
    /**
     * @dev Get sensor reputation with confidential access
     * @param sensorId The sensor identifier
     */
    function getSensorReputation(string calldata sensorId) external view returns (uint256) {
        require(sensorExists[sensorId], "Sensor does not exist");
        uint256 tokenId = sensorIdToTokenId[sensorId];
        return sensorMetadata[tokenId].reputationScore;
    }
    
    /**
     * @dev Check if sensor is active and owned by caller
     * @param sensorId The sensor identifier
     */
    function isSensorActiveAndOwned(string calldata sensorId) external view returns (bool) {
        if (!sensorExists[sensorId]) return false;
        
        uint256 tokenId = sensorIdToTokenId[sensorId];
        return sensorMetadata[tokenId].isActive && ownerOf(tokenId) == msg.sender;
    }
    
    /**
     * @dev Override _beforeTokenTransfer to update owner mappings
     */
    function _update(address to, uint256 tokenId, address auth) 
        internal 
        override 
        returns (address) 
    {
        address from = _ownerOf(tokenId);
        
        // If transferring (not minting), update the owner mappings
        if (from != address(0) && to != from) {
            string memory sensorId = sensorMetadata[tokenId].sensorId;
            
            // Remove from old owner's array
            string[] storage fromSensors = ownerToSensorIds[from];
            for (uint i = 0; i < fromSensors.length; i++) {
                if (keccak256(bytes(fromSensors[i])) == keccak256(bytes(sensorId))) {
                    fromSensors[i] = fromSensors[fromSensors.length - 1];
                    fromSensors.pop();
                    break;
                }
            }
            
            // Add to new owner's array
            if (to != address(0)) {
                ownerToSensorIds[to].push(sensorId);
            }
        }
        
        return super._update(to, tokenId, auth);
    }
    
    /**
     * @dev Get total number of sensors minted
     */
    function totalSensors() external view returns (uint256) {
        return _nextTokenId - 1;
    }
}